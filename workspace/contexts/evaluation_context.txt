You will be prompted with a task. The task has already been solved. Your task is to check if the result is correct, without modifying it. In order to do that we need you to provide a python function (ONLY this function) called evaluation_func(self) that takes no arguments and checks if the results of the prevoius program (that you do not need to compute and are already available as global variables) are correct, only define the function do not call it. The function should return a boolean that tells if the original code was succesful. Only write code. Every kind of explanation should be included as python comments. Your entire response should be directly executable in a python shell.

You are given access to an API:

self.objStates: a dictionary with key-value pairs of the type "<object-name>":[x,y,z] that associate to each object perceived on the scene its 3d xyz coordinates expressed in the world frame

self.initialObjectStates: describes the object positions at the beginning of the task. A dictionary with key-value pairs of the type "<object-name>":[x,y,z] that associate to each object perceived on the scene its 3d xyz coordinates expressed in the world frame.

Rememeber to put a lot of care into evaluating objects relative position. Provide robust code that allows for slight imprecisions in the position.

Here are some examples on how to use the API to check task completion:

Example 1
Task: Pick up the blue cube and place it in coordinates [0.7, 0.1, 0.05]
Code:
    def evaluation_func(self):
        initial_objects = self.initialObjectStates
        objects = self.objStates
        BLUE_CUBE_POSITION = objects["blue_cube"]
        TARGET_POSITION = [0.7, 0.1, 0.05]
        if BLUE_CUBE_POSITION[0] == TARGET_POSITION[0] and \
           BLUE_CUBE_POSITION[1] == TARGET_POSITION[1] and \
           BLUE_CUBE_POSITION[2] == TARGET_POSITION[2]:
            return True
        else:
            return False

Example 2
Task: Pick the green cobe and place it on top of the blue one
Code:
    def evaluation_func(self):
        initial_objects = self.initialObjectStates
        objects = self.objStates
        INITIAL_GREEN_CUBE_POSITION = initial_objects["green_cube]
        INITIAL_BLUE_CUBE_POSITION = initial_objects["blue_cube]
        GREEN_CUBE_POSITION = objects["green_cube"]
        BLUE_CUBE_POSITION = objects["blue_cube"]
        # Logical steps that we need to check
        # 1. Check if only the green cube has been moved
        # 2. Check if the blue cube has been correctly placed on top of the blue one

        # 1.
        blue_not_moved = BLUE_CUBE_POSITION[0] == INITIAL_BLUE_CUBE_POSITION[0] and \
                     BLUE_CUBE_POSITION[1] == INITIAL_BLUE_CUBE_POSITION[1] and \
                     BLUE_CUBE_POSITION[2] == INITIAL_BLUE_CUBE_POSITION[2]

        if not blue_not_moved:
            # The blue cube was supposed to remain fixed
            return False

        # 2.
        TOLERANCE = 0.01
        green_on_blue = abs(GREEN_CUBE_POSITION[0] - BLUE_CUBE_POSITION[0]) < TOLERANCE and \
                        abs(GREEN_CUBE_POSITION[1] - BLUE_CUBE_POSITION[1]) < TOLERANCE and \
                        GREEN_CUBE_POSITION[2] > BLUE_CUBE_POSITION[2]
                    
        if green_on_blue:
            return True
        else:
            return False